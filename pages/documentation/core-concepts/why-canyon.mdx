# why Canyon ?

## 代码覆盖率

随着你编写更多的end-to-end测试case，你会发现自己有一些疑问，我需要写更多的测试用例吗？究竟还有哪些代码没测到？用例会不会重复了？这个时候代码覆盖率就派上用场了，它的原理是在代码执行前将代码探针插入到源代码中（其实就是上下文加计数器），这样每当case执行的时候就可以触发其中的计数器.

在代码中插入代码探针的步骤称为**代码插桩**（instrument）。插桩前的代码：

```js
// add.js
function add(a, b) {
  return a + b
}
module.exports = { add }
```

插桩过程是对代码解析以查找所有函数、语句和分支，然后将计数器插入代码中。对于上面的代码，插桩完成后：

```js
// 这个对象用于计算每个函数和每个语句被执行的次数
const c = (window.__coverage__ = {
  // "f" 记录每个函数被调用的次数
  f: [0],
  // "s" 记录每个语句被调用的次数
  // 我们有3个语句，它们都从0开始
  s: [0, 0, 0],
})

// 第一个语句定义了函数
c.s[0]++
function add(a, b) {
  // 函数被调用后是第二个语句
  c.f[0]++
  c.s[1]++

  return a + b
}
// 第三个语句即将被调用
c.s[2]++
module.exports = { add }

```

我们希望确保文件中的每个语句和函数`add.js`都已被我们的测试至少执行一次。因此我们编写一个测试：

```js
// add.cy.js
const { add } = require('./add')

it('adds numbers', () => {
  expect(add(2, 3)).to.equal(5)
})
```

当测试调用时`add(2, 3)`，执行“add”函数内的计数器递增，覆盖范围对象变为：

```js
{
  f: [1],
  s: [1, 1, 1]
}
```

这个测试用例覆盖率达到了100%，每个函数和每个语句都至少执行了一次。但是在实际应用中，要达到100%的代码覆盖率需要多次测试。

这是覆盖率的基本介绍，有了这个前置知识，方便大家理解下面的内容。

## 端到端测试现状

### Chrome覆盖率工具
### playwright等工具内置的覆盖率工具
### 总的来说

他们的问题是只能检测原生的js代码，无法检测编译后的代码，所以我们需要在编译时插桩。

## Canyon是怎么做的

4. 所以我们要获取到源代码的覆盖率我们需要怎么做？

5. 我们的解决方案是什么？就是编译时插桩。

6. 所以问题就转换成如何在各个测试框架中获取浏览器内的覆盖率数据。

7. 接下来就是适配各个测试框架，如cypress，puppeteer，playwright，jest，mocha等。

8. 在其关键的hooks中收集

9. 再结合构建时的流水线变量来确定源代码的内容

10. 最后在查看报告的时候结合源代码的内容来展示





忽略下面

## 端到端测试当下的问题

1. 先看一下chrome的覆盖率工具，它检测的是什么。

2. 一些流行的端到端测试工具，如cypress，puppeteer，playwright，他们的覆盖率工具是如何实现的。都是基于动态探针插桩，v8 coverage

3. 他们统一的问题是什么？

4. 所以我们要获取到源代码的覆盖率我们需要怎么做？

5. 我们的解决方案是什么？就是编译时插桩。

6. 所以问题就转换成如何在各个测试框架中获取浏览器内的覆盖率数据。

7. 接下来就是适配各个测试框架，如cypress，puppeteer，playwright，jest，mocha等。

8. 在其关键的hooks中收集

9. 再结合构建时的流水线变量来确定源代码的内容

10. 最后在查看报告的时候结合源代码的内容来展示